// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             (unknown)
// source: clash/v1/service.proto

package clashv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	ClashService_SubscribeLogs_FullMethodName        = "/clash.v1.ClashService/SubscribeLogs"
	ClashService_SubscribeTraffics_FullMethodName    = "/clash.v1.ClashService/SubscribeTraffics"
	ClashService_SubscribeConnections_FullMethodName = "/clash.v1.ClashService/SubscribeConnections"
	ClashService_Version_FullMethodName              = "/clash.v1.ClashService/Version"
	ClashService_ListRules_FullMethodName            = "/clash.v1.ClashService/ListRules"
	ClashService_ListInbounds_FullMethodName         = "/clash.v1.ClashService/ListInbounds"
	ClashService_BatchUpdateInbounds_FullMethodName  = "/clash.v1.ClashService/BatchUpdateInbounds"
	ClashService_DeleteConnection_FullMethodName     = "/clash.v1.ClashService/DeleteConnection"
	ClashService_CloseAllConnections_FullMethodName  = "/clash.v1.ClashService/CloseAllConnections"
	ClashService_QueryDNS_FullMethodName             = "/clash.v1.ClashService/QueryDNS"
)

// ClashServiceClient is the client API for ClashService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ClashServiceClient interface {
	SubscribeLogs(ctx context.Context, in *SubscribeLogsRequest, opts ...grpc.CallOption) (ClashService_SubscribeLogsClient, error)
	SubscribeTraffics(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (ClashService_SubscribeTrafficsClient, error)
	SubscribeConnections(ctx context.Context, in *SubscribeConnectionsRequest, opts ...grpc.CallOption) (ClashService_SubscribeConnectionsClient, error)
	Version(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*VersionResponse, error)
	ListRules(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListRulesResponse, error)
	ListInbounds(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListInboundsResponse, error)
	BatchUpdateInbounds(ctx context.Context, in *BatchUpdateInboundsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	DeleteConnection(ctx context.Context, in *DeleteConnectionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	CloseAllConnections(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	QueryDNS(ctx context.Context, in *QueryDNSRequest, opts ...grpc.CallOption) (*QueryDNSResponse, error)
}

type clashServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewClashServiceClient(cc grpc.ClientConnInterface) ClashServiceClient {
	return &clashServiceClient{cc}
}

func (c *clashServiceClient) SubscribeLogs(ctx context.Context, in *SubscribeLogsRequest, opts ...grpc.CallOption) (ClashService_SubscribeLogsClient, error) {
	stream, err := c.cc.NewStream(ctx, &ClashService_ServiceDesc.Streams[0], ClashService_SubscribeLogs_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &clashServiceSubscribeLogsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ClashService_SubscribeLogsClient interface {
	Recv() (*LogRecord, error)
	grpc.ClientStream
}

type clashServiceSubscribeLogsClient struct {
	grpc.ClientStream
}

func (x *clashServiceSubscribeLogsClient) Recv() (*LogRecord, error) {
	m := new(LogRecord)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *clashServiceClient) SubscribeTraffics(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (ClashService_SubscribeTrafficsClient, error) {
	stream, err := c.cc.NewStream(ctx, &ClashService_ServiceDesc.Streams[1], ClashService_SubscribeTraffics_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &clashServiceSubscribeTrafficsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ClashService_SubscribeTrafficsClient interface {
	Recv() (*Traffic, error)
	grpc.ClientStream
}

type clashServiceSubscribeTrafficsClient struct {
	grpc.ClientStream
}

func (x *clashServiceSubscribeTrafficsClient) Recv() (*Traffic, error) {
	m := new(Traffic)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *clashServiceClient) SubscribeConnections(ctx context.Context, in *SubscribeConnectionsRequest, opts ...grpc.CallOption) (ClashService_SubscribeConnectionsClient, error) {
	stream, err := c.cc.NewStream(ctx, &ClashService_ServiceDesc.Streams[2], ClashService_SubscribeConnections_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &clashServiceSubscribeConnectionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ClashService_SubscribeConnectionsClient interface {
	Recv() (*SubscribeConnectionsResponse, error)
	grpc.ClientStream
}

type clashServiceSubscribeConnectionsClient struct {
	grpc.ClientStream
}

func (x *clashServiceSubscribeConnectionsClient) Recv() (*SubscribeConnectionsResponse, error) {
	m := new(SubscribeConnectionsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *clashServiceClient) Version(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*VersionResponse, error) {
	out := new(VersionResponse)
	err := c.cc.Invoke(ctx, ClashService_Version_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clashServiceClient) ListRules(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListRulesResponse, error) {
	out := new(ListRulesResponse)
	err := c.cc.Invoke(ctx, ClashService_ListRules_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clashServiceClient) ListInbounds(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListInboundsResponse, error) {
	out := new(ListInboundsResponse)
	err := c.cc.Invoke(ctx, ClashService_ListInbounds_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clashServiceClient) BatchUpdateInbounds(ctx context.Context, in *BatchUpdateInboundsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ClashService_BatchUpdateInbounds_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clashServiceClient) DeleteConnection(ctx context.Context, in *DeleteConnectionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ClashService_DeleteConnection_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clashServiceClient) CloseAllConnections(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ClashService_CloseAllConnections_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clashServiceClient) QueryDNS(ctx context.Context, in *QueryDNSRequest, opts ...grpc.CallOption) (*QueryDNSResponse, error) {
	out := new(QueryDNSResponse)
	err := c.cc.Invoke(ctx, ClashService_QueryDNS_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ClashServiceServer is the server API for ClashService service.
// All implementations must embed UnimplementedClashServiceServer
// for forward compatibility
type ClashServiceServer interface {
	SubscribeLogs(*SubscribeLogsRequest, ClashService_SubscribeLogsServer) error
	SubscribeTraffics(*emptypb.Empty, ClashService_SubscribeTrafficsServer) error
	SubscribeConnections(*SubscribeConnectionsRequest, ClashService_SubscribeConnectionsServer) error
	Version(context.Context, *emptypb.Empty) (*VersionResponse, error)
	ListRules(context.Context, *emptypb.Empty) (*ListRulesResponse, error)
	ListInbounds(context.Context, *emptypb.Empty) (*ListInboundsResponse, error)
	BatchUpdateInbounds(context.Context, *BatchUpdateInboundsRequest) (*emptypb.Empty, error)
	DeleteConnection(context.Context, *DeleteConnectionRequest) (*emptypb.Empty, error)
	CloseAllConnections(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	QueryDNS(context.Context, *QueryDNSRequest) (*QueryDNSResponse, error)
	mustEmbedUnimplementedClashServiceServer()
}

// UnimplementedClashServiceServer must be embedded to have forward compatible implementations.
type UnimplementedClashServiceServer struct {
}

func (UnimplementedClashServiceServer) SubscribeLogs(*SubscribeLogsRequest, ClashService_SubscribeLogsServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeLogs not implemented")
}
func (UnimplementedClashServiceServer) SubscribeTraffics(*emptypb.Empty, ClashService_SubscribeTrafficsServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeTraffics not implemented")
}
func (UnimplementedClashServiceServer) SubscribeConnections(*SubscribeConnectionsRequest, ClashService_SubscribeConnectionsServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeConnections not implemented")
}
func (UnimplementedClashServiceServer) Version(context.Context, *emptypb.Empty) (*VersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Version not implemented")
}
func (UnimplementedClashServiceServer) ListRules(context.Context, *emptypb.Empty) (*ListRulesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRules not implemented")
}
func (UnimplementedClashServiceServer) ListInbounds(context.Context, *emptypb.Empty) (*ListInboundsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListInbounds not implemented")
}
func (UnimplementedClashServiceServer) BatchUpdateInbounds(context.Context, *BatchUpdateInboundsRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchUpdateInbounds not implemented")
}
func (UnimplementedClashServiceServer) DeleteConnection(context.Context, *DeleteConnectionRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteConnection not implemented")
}
func (UnimplementedClashServiceServer) CloseAllConnections(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseAllConnections not implemented")
}
func (UnimplementedClashServiceServer) QueryDNS(context.Context, *QueryDNSRequest) (*QueryDNSResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryDNS not implemented")
}
func (UnimplementedClashServiceServer) mustEmbedUnimplementedClashServiceServer() {}

// UnsafeClashServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ClashServiceServer will
// result in compilation errors.
type UnsafeClashServiceServer interface {
	mustEmbedUnimplementedClashServiceServer()
}

func RegisterClashServiceServer(s grpc.ServiceRegistrar, srv ClashServiceServer) {
	s.RegisterService(&ClashService_ServiceDesc, srv)
}

func _ClashService_SubscribeLogs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeLogsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ClashServiceServer).SubscribeLogs(m, &clashServiceSubscribeLogsServer{stream})
}

type ClashService_SubscribeLogsServer interface {
	Send(*LogRecord) error
	grpc.ServerStream
}

type clashServiceSubscribeLogsServer struct {
	grpc.ServerStream
}

func (x *clashServiceSubscribeLogsServer) Send(m *LogRecord) error {
	return x.ServerStream.SendMsg(m)
}

func _ClashService_SubscribeTraffics_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(emptypb.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ClashServiceServer).SubscribeTraffics(m, &clashServiceSubscribeTrafficsServer{stream})
}

type ClashService_SubscribeTrafficsServer interface {
	Send(*Traffic) error
	grpc.ServerStream
}

type clashServiceSubscribeTrafficsServer struct {
	grpc.ServerStream
}

func (x *clashServiceSubscribeTrafficsServer) Send(m *Traffic) error {
	return x.ServerStream.SendMsg(m)
}

func _ClashService_SubscribeConnections_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeConnectionsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ClashServiceServer).SubscribeConnections(m, &clashServiceSubscribeConnectionsServer{stream})
}

type ClashService_SubscribeConnectionsServer interface {
	Send(*SubscribeConnectionsResponse) error
	grpc.ServerStream
}

type clashServiceSubscribeConnectionsServer struct {
	grpc.ServerStream
}

func (x *clashServiceSubscribeConnectionsServer) Send(m *SubscribeConnectionsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _ClashService_Version_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClashServiceServer).Version(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClashService_Version_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClashServiceServer).Version(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClashService_ListRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClashServiceServer).ListRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClashService_ListRules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClashServiceServer).ListRules(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClashService_ListInbounds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClashServiceServer).ListInbounds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClashService_ListInbounds_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClashServiceServer).ListInbounds(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClashService_BatchUpdateInbounds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchUpdateInboundsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClashServiceServer).BatchUpdateInbounds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClashService_BatchUpdateInbounds_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClashServiceServer).BatchUpdateInbounds(ctx, req.(*BatchUpdateInboundsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClashService_DeleteConnection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteConnectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClashServiceServer).DeleteConnection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClashService_DeleteConnection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClashServiceServer).DeleteConnection(ctx, req.(*DeleteConnectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClashService_CloseAllConnections_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClashServiceServer).CloseAllConnections(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClashService_CloseAllConnections_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClashServiceServer).CloseAllConnections(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClashService_QueryDNS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryDNSRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClashServiceServer).QueryDNS(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClashService_QueryDNS_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClashServiceServer).QueryDNS(ctx, req.(*QueryDNSRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ClashService_ServiceDesc is the grpc.ServiceDesc for ClashService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ClashService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "clash.v1.ClashService",
	HandlerType: (*ClashServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Version",
			Handler:    _ClashService_Version_Handler,
		},
		{
			MethodName: "ListRules",
			Handler:    _ClashService_ListRules_Handler,
		},
		{
			MethodName: "ListInbounds",
			Handler:    _ClashService_ListInbounds_Handler,
		},
		{
			MethodName: "BatchUpdateInbounds",
			Handler:    _ClashService_BatchUpdateInbounds_Handler,
		},
		{
			MethodName: "DeleteConnection",
			Handler:    _ClashService_DeleteConnection_Handler,
		},
		{
			MethodName: "CloseAllConnections",
			Handler:    _ClashService_CloseAllConnections_Handler,
		},
		{
			MethodName: "QueryDNS",
			Handler:    _ClashService_QueryDNS_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeLogs",
			Handler:       _ClashService_SubscribeLogs_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeTraffics",
			Handler:       _ClashService_SubscribeTraffics_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeConnections",
			Handler:       _ClashService_SubscribeConnections_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "clash/v1/service.proto",
}
